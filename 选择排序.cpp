#include <stdio.h>






//选择法简单排序
//记元素位置
//简单的排序算法的时间复杂度全是O(n**2)
//

//树形选择排序
//利用关系的可传递性
//时间复杂度O(n *log2 n)

//堆排序
//堆的定义
//堆：优先队列，先进先出
//第一个元素是当前优先级最高的
//看作一个顺序表，完全二叉树的对应关系
//如果有左孩子，就在2n上，如果有右孩子，就在2n+1上
//堆是采取顺序存储的完全二叉树
//堆的根节点是关键字序列中的最小，成为小根堆
//堆中的任意子树也是堆
//从根节点到每一叶子节点路径上的？？？
//
//
//按堆的定义建立堆
//
//将堆顶记录和最后一个记录交换位置，则前n-1个记录是无序的，而最后一个记录是有序的
//
//对丁记录被交换后，前n-1个记录不再是堆，需将前n-1个待排序记录重新组织成为一个堆，
//然后将对丁记录和倒数第二个记录交换位置，
//，即将整个序列中次小关键字值的记录调整出无序区
//
//重复上述步骤，知道全部的记录排好序为止
//
//结论：排序过程中，若采用小根堆，排序后得到的是非递减序列，若采用大根堆，排序后得到的是非递增序列